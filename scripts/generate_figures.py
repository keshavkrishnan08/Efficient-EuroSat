#!/usr/bin/env python3
"""Phase 4: Master figure generation for the EfficientEuroSAT IEEE paper.

Reads saved JSON results from Phase 3 analysis scripts and generates
publication-quality figures suitable for a two-column IEEE conference paper.

Expected input files (relative to --results_dir):
    accuracy/evaluation_results.json   (from evaluate.py / run_evaluation.py)
    ucat/ucat_analysis.json            (from analyze_ucat.py)
    ood/ood_results.json               (from analyze_ood.py)
    calibration/calibration_results.json (from analyze_calibration.py)
    robustness/robustness_results.json (from analyze_robustness.py)

Generated figures (saved to --output_dir):
    fig2_tau_entropy_scatter.png   -- tau vs entropy scatter plot
    fig3_correct_vs_wrong.png      -- box/violin: tau for correct vs incorrect
    fig4_ood_detection.png         -- OOD detection ROC / histogram summary
    fig5_calibration_comparison.png -- side-by-side reliability diagrams
    fig6_robustness.png            -- dual-axis bar chart per corruption
    fig7_ablation_accuracy.png     -- bar chart of ablation test accuracies

Usage:
    python scripts/generate_figures.py
    python scripts/generate_figures.py --results_dir ./analysis_results --output_dir ./figures --dpi 300
"""

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

import argparse
import json
import os
import sys

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

import numpy as np


# ============================================================================
# IEEE paper style constants
# ============================================================================
TITLE_SIZE = 12
LABEL_SIZE = 10
TICK_SIZE = 8
LEGEND_SIZE = 8


def _apply_ieee_style():
    """Set matplotlib rcParams for IEEE two-column paper figures."""
    plt.rcParams.update({
        "font.size": TICK_SIZE,
        "axes.titlesize": TITLE_SIZE,
        "axes.labelsize": LABEL_SIZE,
        "xtick.labelsize": TICK_SIZE,
        "ytick.labelsize": TICK_SIZE,
        "legend.fontsize": LEGEND_SIZE,
        "figure.dpi": 150,
        "savefig.dpi": 300,
        "axes.grid": False,
        "grid.alpha": 0.3,
        "figure.facecolor": "white",
        "axes.facecolor": "white",
        "savefig.facecolor": "white",
    })


# ============================================================================
# Helper I/O
# ============================================================================

def _load_json(path):
    """Load a JSON file and return the parsed dict, or None on failure."""
    if not os.path.isfile(path):
        return None
    try:
        with open(path, "r") as f:
            return json.load(f)
    except (json.JSONDecodeError, OSError) as exc:
        print(f"  WARNING: failed to load {path}: {exc}")
        return None


# ============================================================================
# Figure 2: tau vs Entropy Scatter
# ============================================================================

def generate_fig2(ucat_data, output_dir, dpi):
    """Generate Fig 2: temperature vs prediction entropy scatter plot.

    If raw arrays (temperatures, entropies) are present in the UCAT results
    JSON, a full scatter plot with regression line is produced.  Otherwise a
    note is printed that the plot was already generated by analyze_ucat.py.

    Parameters
    ----------
    ucat_data : dict
        Parsed contents of ucat_analysis.json.
    output_dir : str
        Directory for saving the figure.
    dpi : int
        Resolution for the saved image.

    Returns
    -------
    bool
        True if the figure was created and saved.
    """
    save_path = os.path.join(output_dir, "fig2_tau_entropy_scatter.png")

    # Check for raw arrays -- the analysis script may or may not serialise
    # them (they are numpy arrays at runtime but lists in JSON).
    temperatures = ucat_data.get("temperatures")
    entropies = ucat_data.get("entropies")

    # Also look inside the nested a2 summary dict
    a2 = ucat_data.get("a2_temperature_entropy_correlation", {})
    pearson_r = a2.get("pearson_r", ucat_data.get("correlation", None))
    temp_mean = a2.get("temperature_mean")
    temp_std = a2.get("temperature_std")
    entropy_mean = a2.get("entropy_mean")
    entropy_std = a2.get("entropy_std")

    if temperatures is not None and entropies is not None:
        temps = np.asarray(temperatures, dtype=np.float64)
        ents = np.asarray(entropies, dtype=np.float64)
        corr_vals = ucat_data.get("correct")

        fig, ax = plt.subplots(figsize=(5, 3.5))

        # Colour by correctness if available
        if corr_vals is not None:
            corr_arr = np.asarray(corr_vals, dtype=np.float64)
            colors = np.where(corr_arr == 1.0, "#4CAF50", "#F44336")
            ax.scatter(ents, temps, c=colors, alpha=0.35, s=6,
                       edgecolors="none", rasterized=True)
            # Manual legend entries
            ax.scatter([], [], c="#4CAF50", s=20, label="Correct")
            ax.scatter([], [], c="#F44336", s=20, label="Incorrect")
        else:
            ax.scatter(ents, temps, alpha=0.35, s=6, color="steelblue",
                       edgecolors="none", rasterized=True)

        # Regression line
        if len(ents) > 2 and np.std(ents) > 1e-8 and np.std(temps) > 1e-8:
            z = np.polyfit(ents, temps, 1)
            p = np.poly1d(z)
            x_line = np.linspace(ents.min(), ents.max(), 100)
            r_val = pearson_r if pearson_r is not None else float(
                np.corrcoef(ents, temps)[0, 1]
            )
            ax.plot(x_line, p(x_line), "b--", linewidth=1.5,
                    label=f"r = {r_val:.3f}")

        ax.set_xlabel("Prediction Entropy")
        ax.set_ylabel("Attention Temperature ($\\tau$)")
        ax.set_title("Temperature--Entropy Correlation")
        ax.legend(loc="best")

        fig.tight_layout()
        fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
        plt.close(fig)
        print(f"  Saved: {save_path}")
        return True

    # No raw arrays -- fall back to a summary annotation figure
    if pearson_r is not None:
        fig, ax = plt.subplots(figsize=(5, 3.5))
        text_lines = [
            "Scatter generated by analyze_ucat.py",
            "",
            f"Pearson r = {pearson_r:.4f}",
        ]
        if temp_mean is not None:
            text_lines.append(
                f"Temperature: {temp_mean:.4f} +/- {temp_std:.4f}"
            )
        if entropy_mean is not None:
            text_lines.append(
                f"Entropy: {entropy_mean:.4f} +/- {entropy_std:.4f}"
            )
        ax.text(0.5, 0.5, "\n".join(text_lines),
                ha="center", va="center", transform=ax.transAxes,
                fontsize=LABEL_SIZE, family="monospace",
                bbox=dict(boxstyle="round,pad=0.5", facecolor="#e8f5e9",
                          edgecolor="gray"))
        ax.set_title("Temperature--Entropy Correlation (Summary)")
        ax.set_xticks([])
        ax.set_yticks([])
        fig.tight_layout()
        fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
        plt.close(fig)
        print(f"  Saved (summary): {save_path}")
        print("  Note: full scatter was already generated by analyze_ucat.py")
        return True

    return False


# ============================================================================
# Figure 3: tau for Correct vs Wrong
# ============================================================================

def generate_fig3(ucat_data, output_dir, dpi):
    """Generate Fig 3: box/violin plot of tau for correct vs incorrect.

    Parameters
    ----------
    ucat_data : dict
        Parsed UCAT analysis JSON.
    output_dir : str
        Output directory.
    dpi : int
        Image resolution.

    Returns
    -------
    bool
        True if the figure was created.
    """
    save_path = os.path.join(output_dir, "fig3_correct_vs_wrong.png")

    # Try to extract raw temperature and correctness arrays
    temperatures = ucat_data.get("temperatures")
    correct = ucat_data.get("correct")

    # Fall back to summary statistics from the nested dict
    a3 = ucat_data.get("a3_correct_vs_incorrect", {})
    mean_correct = a3.get("mean_tau_correct")
    mean_incorrect = a3.get("mean_tau_incorrect")
    n_correct = a3.get("num_correct")
    n_incorrect = a3.get("num_incorrect")

    if temperatures is not None and correct is not None:
        temps = np.asarray(temperatures, dtype=np.float64)
        corr = np.asarray(correct, dtype=np.float64)

        temps_correct = temps[corr == 1.0]
        temps_incorrect = temps[corr == 0.0]

        if len(temps_correct) == 0 and len(temps_incorrect) == 0:
            print("  Skipping fig3: no correct/incorrect data.")
            return False

        fig, ax = plt.subplots(figsize=(4.5, 3.5))

        box_data = []
        box_labels = []
        colors = []

        if len(temps_correct) > 0:
            box_data.append(temps_correct)
            box_labels.append(f"Correct\n(n={len(temps_correct)})")
            colors.append("#4CAF50")
        if len(temps_incorrect) > 0:
            box_data.append(temps_incorrect)
            box_labels.append(f"Incorrect\n(n={len(temps_incorrect)})")
            colors.append("#F44336")

        bp = ax.boxplot(box_data, labels=box_labels, patch_artist=True,
                        widths=0.45, showfliers=True,
                        flierprops=dict(marker=".", markersize=2, alpha=0.4))

        for patch, color in zip(bp["boxes"], colors):
            patch.set_facecolor(color)
            patch.set_alpha(0.55)

        for median in bp["medians"]:
            median.set_color("black")
            median.set_linewidth(1.5)

        ax.set_ylabel("Attention Temperature ($\\tau$)")
        ax.set_title("Temperature: Correct vs Incorrect Predictions")
        ax.grid(axis="y", alpha=0.25, linewidth=0.5)

        fig.tight_layout()
        fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
        plt.close(fig)
        print(f"  Saved: {save_path}")
        return True

    # Summary-only fallback
    if mean_correct is not None and mean_incorrect is not None:
        fig, ax = plt.subplots(figsize=(4.5, 3.5))

        categories = []
        means = []
        colors = []

        if n_correct is not None and n_correct > 0:
            categories.append(f"Correct\n(n={n_correct})")
            means.append(mean_correct)
            colors.append("#4CAF50")
        else:
            categories.append("Correct")
            means.append(mean_correct)
            colors.append("#4CAF50")

        if n_incorrect is not None and n_incorrect > 0:
            categories.append(f"Incorrect\n(n={n_incorrect})")
            means.append(mean_incorrect)
            colors.append("#F44336")
        else:
            categories.append("Incorrect")
            means.append(mean_incorrect)
            colors.append("#F44336")

        bars = ax.bar(categories, means, color=colors, alpha=0.65, width=0.45,
                      edgecolor="black", linewidth=0.5)

        # Value labels on top of bars
        for bar, val in zip(bars, means):
            ax.text(bar.get_x() + bar.get_width() / 2, bar.get_height(),
                    f"{val:.4f}", ha="center", va="bottom",
                    fontsize=TICK_SIZE)

        ax.set_ylabel("Mean Attention Temperature ($\\tau$)")
        ax.set_title("Temperature: Correct vs Incorrect (Mean)")
        ax.grid(axis="y", alpha=0.25, linewidth=0.5)

        fig.tight_layout()
        fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
        plt.close(fig)
        print(f"  Saved (summary bars): {save_path}")
        return True

    return False


# ============================================================================
# Figure 4: OOD Detection
# ============================================================================

def generate_fig4(ood_data, output_dir, dpi):
    """Generate Fig 4: OOD detection summary figure.

    If raw temperature arrays are present, overlapping histograms of
    in-distribution vs OOD temperatures are plotted.  Otherwise an
    ROC-style summary card showing the AUROC value is generated.

    Parameters
    ----------
    ood_data : dict
        Parsed OOD results JSON.
    output_dir : str
        Output directory.
    dpi : int
        Image resolution.

    Returns
    -------
    bool
        True if the figure was created.
    """
    save_path = os.path.join(output_dir, "fig4_ood_detection.png")

    auroc = ood_data.get("auroc")
    aupr = ood_data.get("aupr")
    fpr95 = ood_data.get("fpr_at_95_tpr")
    mean_in = ood_data.get("mean_in_temp")
    mean_ood = ood_data.get("mean_ood_temp")
    temp_gap = ood_data.get("temp_gap")

    in_temps = ood_data.get("in_temps")
    ood_temps = ood_data.get("ood_temps")

    if auroc is None:
        return False

    # ------- Histogram when raw temps available ------- #
    if in_temps is not None and ood_temps is not None:
        in_arr = np.asarray(in_temps, dtype=np.float64)
        ood_arr = np.asarray(ood_temps, dtype=np.float64)

        fig, ax = plt.subplots(figsize=(5, 3.5))

        in_label = f"In-dist (EuroSAT, $\\mu$={in_arr.mean():.3f})"
        ood_label = f"OOD (DTD, $\\mu$={ood_arr.mean():.3f})"

        ax.hist(in_arr, bins=50, alpha=0.55, density=True,
                label=in_label, color="steelblue", edgecolor="none")
        ax.hist(ood_arr, bins=50, alpha=0.55, density=True,
                label=ood_label, color="coral", edgecolor="none")

        ax.set_xlabel("Attention Temperature ($\\tau$)")
        ax.set_ylabel("Density")
        ax.set_title(f"OOD Detection via UCAT Temperature (AUROC={auroc:.3f})")
        ax.legend(loc="upper right")

        fig.tight_layout()
        fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
        plt.close(fig)
        print(f"  Saved: {save_path}")
        return True

    # ------- Summary card when no raw temps ------- #
    fig, ax = plt.subplots(figsize=(5, 3.5))

    # Large AUROC display
    ax.text(0.5, 0.62, f"AUROC = {auroc:.4f}",
            ha="center", va="center", transform=ax.transAxes,
            fontsize=20, fontweight="bold", color="steelblue")

    detail_lines = []
    if aupr is not None:
        detail_lines.append(f"AUPR: {aupr:.4f}")
    if fpr95 is not None:
        detail_lines.append(f"FPR@95TPR: {fpr95:.4f}")
    if mean_in is not None and mean_ood is not None:
        detail_lines.append(
            f"Mean temp -- in: {mean_in:.4f}, OOD: {mean_ood:.4f}"
        )
    if temp_gap is not None:
        detail_lines.append(f"Temperature gap: {temp_gap:.4f}")

    ax.text(0.5, 0.28, "\n".join(detail_lines),
            ha="center", va="center", transform=ax.transAxes,
            fontsize=TICK_SIZE, family="monospace",
            bbox=dict(boxstyle="round,pad=0.4", facecolor="#e3f2fd",
                      edgecolor="gray", alpha=0.8))

    ax.set_title("OOD Detection via UCAT Temperature")
    ax.set_xticks([])
    ax.set_yticks([])

    fig.tight_layout()
    fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
    plt.close(fig)
    print(f"  Saved (summary card): {save_path}")
    return True


# ============================================================================
# Figure 5: Calibration Comparison
# ============================================================================

def generate_fig5(calib_data, output_dir, dpi):
    """Generate Fig 5: side-by-side reliability diagrams for baseline vs UCAT.

    Parameters
    ----------
    calib_data : dict
        Parsed calibration_results.json.
    output_dir : str
        Output directory.
    dpi : int
        Image resolution.

    Returns
    -------
    bool
        True if the figure was created.
    """
    save_path = os.path.join(output_dir, "fig5_calibration_comparison.png")

    baseline = calib_data.get("baseline")
    ucat = calib_data.get("ucat")

    if baseline is None or ucat is None:
        print("  Skipping fig5: missing baseline or ucat calibration data.")
        return False

    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(7, 3.5))

    for ax, results, model_name in [
        (ax1, baseline, "Baseline"),
        (ax2, ucat, "UCAT"),
    ]:
        bin_conf = np.asarray(results.get("bin_confidences", []))
        bin_acc = np.asarray(results.get("bin_accuracies", []))
        bin_counts = np.asarray(results.get("bin_counts", []))
        ece = results.get("ece", 0.0)

        if len(bin_conf) == 0:
            ax.text(0.5, 0.5, "No bin data", ha="center", va="center",
                    transform=ax.transAxes)
            ax.set_title(f"{model_name} (ECE={ece:.4f})")
            continue

        mask = bin_counts > 0
        n_bins = len(bin_conf)
        bar_width = 1.0 / n_bins

        # Reliability bars
        ax.bar(bin_conf[mask], bin_acc[mask], width=bar_width, alpha=0.55,
               edgecolor="black", linewidth=0.4, color="steelblue",
               label="Outputs")

        # Gap shading
        for bc, ba in zip(bin_conf[mask], bin_acc[mask]):
            gap_color = "#F44336" if ba < bc else "#4CAF50"
            ax.bar(bc, abs(ba - bc), bottom=min(ba, bc),
                   width=bar_width, alpha=0.2, color=gap_color,
                   edgecolor="none")

        # Perfect calibration line
        ax.plot([0, 1], [0, 1], "k--", linewidth=0.8, label="Perfect")

        ax.set_xlabel("Confidence")
        ax.set_ylabel("Accuracy")
        ax.set_title(f"{model_name} (ECE={ece:.4f})")
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.legend(loc="upper left")

    fig.suptitle("Calibration: Baseline vs UCAT", fontsize=TITLE_SIZE, y=1.02)
    fig.tight_layout()
    fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
    plt.close(fig)
    print(f"  Saved: {save_path}")
    return True


# ============================================================================
# Figure 6: Robustness
# ============================================================================

def generate_fig6(robust_data, output_dir, dpi):
    """Generate Fig 6: dual-axis bar chart of accuracy and temperature by corruption.

    Parameters
    ----------
    robust_data : dict
        Parsed robustness_results.json.  Keys are corruption names (including
        ``'clean'``), values are dicts with ``'accuracy'`` and ``'mean_temp'``.
    output_dir : str
        Output directory.
    dpi : int
        Image resolution.

    Returns
    -------
    bool
        True if the figure was created.
    """
    save_path = os.path.join(output_dir, "fig6_robustness.png")

    if not robust_data:
        return False

    # Order: clean first, then corruptions sorted alphabetically
    names = sorted([k for k in robust_data if k != "clean"])
    names = ["clean"] + names

    # Validate that entries have the expected fields
    valid_names = []
    for n in names:
        entry = robust_data.get(n, {})
        if isinstance(entry, dict) and "accuracy" in entry and "mean_temp" in entry:
            valid_names.append(n)

    if len(valid_names) == 0:
        print("  Skipping fig6: no valid robustness entries found.")
        return False

    accs = [robust_data[n]["accuracy"] for n in valid_names]
    temps = [robust_data[n]["mean_temp"] for n in valid_names]

    # Pretty labels
    label_map = {
        "clean": "Clean",
        "gaussian_blur": "Gauss. Blur",
        "color_jitter": "Color Jitter",
        "gaussian_noise": "Gauss. Noise",
        "brightness_up": "Brightness",
        "contrast_down": "Contrast",
    }
    labels = [label_map.get(n, n.replace("_", " ").title()) for n in valid_names]

    x = np.arange(len(valid_names))
    width = 0.35

    fig, ax1 = plt.subplots(figsize=(6, 3.5))

    # Accuracy bars (left y-axis)
    bars1 = ax1.bar(x - width / 2, accs, width, label="Accuracy",
                    color="steelblue", alpha=0.75, edgecolor="none")
    ax1.set_ylabel("Accuracy", color="steelblue")
    ax1.set_ylim(0, 1.08)
    ax1.tick_params(axis="y", labelcolor="steelblue")

    # Temperature bars (right y-axis)
    ax2 = ax1.twinx()
    bars2 = ax2.bar(x + width / 2, temps, width, label="Temperature",
                    color="coral", alpha=0.75, edgecolor="none")
    ax2.set_ylabel("Temperature ($\\tau$)", color="coral")
    ax2.tick_params(axis="y", labelcolor="coral")

    ax1.set_xticks(x)
    ax1.set_xticklabels(labels, rotation=30, ha="right")
    ax1.set_title("Robustness: Accuracy and Temperature by Corruption")

    # Combined legend
    handles1, labels1 = ax1.get_legend_handles_labels()
    handles2, labels2 = ax2.get_legend_handles_labels()
    ax1.legend(handles1 + handles2, labels1 + labels2, loc="upper right")

    fig.tight_layout()
    fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
    plt.close(fig)
    print(f"  Saved: {save_path}")
    return True


# ============================================================================
# Figure 7: Ablation Bar Chart
# ============================================================================

def generate_fig7(acc_data, output_dir, dpi):
    """Generate Fig 7: bar chart of test accuracy for ablation configurations.

    The script looks for ablation-style results in the accuracy JSON.  It
    supports two common layouts:

    1. A list of dicts with ``'config_name'`` and ``'test_accuracy_mean'``
       keys (from ablation_study.py aggregated_results.json).
    2. A single evaluation dict with ``'accuracy'`` -> ``'overall_accuracy'``
       alongside per-class results (from evaluate.py).

    Parameters
    ----------
    acc_data : dict or list
        Parsed evaluation_results.json (or aggregated_results.json).
    output_dir : str
        Output directory.
    dpi : int
        Image resolution.

    Returns
    -------
    bool
        True if the figure was created.
    """
    save_path = os.path.join(output_dir, "fig7_ablation_accuracy.png")

    config_names = []
    accuracies = []

    # Layout 1: list of aggregated ablation results
    if isinstance(acc_data, list):
        for entry in acc_data:
            name = entry.get("config_name", entry.get("name", ""))
            acc = entry.get("test_accuracy_mean", entry.get("test_accuracy"))
            if name and acc is not None:
                config_names.append(name)
                accuracies.append(float(acc))

    # Layout 2: single result with a nested "configs" or "ablation" list
    elif isinstance(acc_data, dict):
        # Check for embedded ablation list
        for key in ("configs", "ablation", "results", "experiments"):
            if key in acc_data and isinstance(acc_data[key], list):
                for entry in acc_data[key]:
                    name = entry.get("config_name", entry.get("name", ""))
                    acc = entry.get("test_accuracy_mean",
                                    entry.get("test_accuracy"))
                    if name and acc is not None:
                        config_names.append(name)
                        accuracies.append(float(acc))
                break

        # Fallback: per-class accuracy from evaluate.py
        if not config_names:
            pca = None
            if "accuracy" in acc_data and isinstance(acc_data["accuracy"], dict):
                pca = acc_data["accuracy"].get("per_class_accuracy")
            elif "per_class_accuracy" in acc_data:
                pca = acc_data["per_class_accuracy"]

            if pca is not None and isinstance(pca, dict):
                # Use class IDs as config names
                for class_id in sorted(pca.keys(), key=lambda k: int(k)):
                    config_names.append(f"Class {class_id}")
                    accuracies.append(float(pca[class_id]))

    if len(config_names) == 0:
        print("  Skipping fig7: no ablation/accuracy config data found.")
        return False

    # Truncate to first 10 for the ablation bar chart specification
    config_names = config_names[:10]
    accuracies = accuracies[:10]

    # Pretty label mapping for ablation configs
    label_map = {
        "baseline_none": "Baseline",
        "full_model": "Full Model",
        "only_LTemp": "+LTemp",
        "only_EExit": "+EExit",
        "only_LDrop": "+LDrop",
        "only_LResid": "+LResid",
        "only_TAnneal": "+TAnneal",
        "no_LTemp": "-LTemp",
        "no_EExit": "-EExit",
        "no_LDrop": "-LDrop",
        "no_LResid": "-LResid",
        "no_TAnneal": "-TAnneal",
    }
    labels = [label_map.get(n, n.replace("_", " ")) for n in config_names]

    x = np.arange(len(labels))

    # Colour: highlight best in dark, full model in medium, rest in light
    accs_arr = np.array(accuracies)
    best_idx = int(np.argmax(accs_arr))
    colors = []
    for i, name in enumerate(config_names):
        if i == best_idx:
            colors.append("#1565C0")          # deep blue for best
        elif name == "full_model":
            colors.append("#42A5F5")          # medium blue for full model
        elif name == "baseline_none":
            colors.append("#BDBDBD")          # grey for baseline
        else:
            colors.append("#90CAF9")          # light blue for others

    fig, ax = plt.subplots(figsize=(6.5, 3.5))

    bars = ax.bar(x, accs_arr * 100, color=colors, edgecolor="none",
                  alpha=0.85, width=0.6)

    # Value labels on top of each bar
    for bar, acc in zip(bars, accuracies):
        ax.text(bar.get_x() + bar.get_width() / 2,
                bar.get_height() + 0.3,
                f"{acc * 100:.1f}",
                ha="center", va="bottom", fontsize=7)

    ax.set_xticks(x)
    ax.set_xticklabels(labels, rotation=40, ha="right")
    ax.set_ylabel("Test Accuracy (%)")
    ax.set_title("Ablation Study: Test Accuracy by Configuration")

    # Tight y-axis around the data range
    y_min = max(0, accs_arr.min() * 100 - 5)
    y_max = min(100, accs_arr.max() * 100 + 3)
    ax.set_ylim(y_min, y_max)
    ax.grid(axis="y", alpha=0.25, linewidth=0.5)

    fig.tight_layout()
    fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
    plt.close(fig)
    print(f"  Saved: {save_path}")
    return True


# ============================================================================
# Figure 8: Decomposition Scatter (tau_a vs tau_e)
# ============================================================================

def generate_fig8(decomp_data, output_dir, dpi):
    """Generate Fig 8: aleatoric vs epistemic temperature scatter.

    Parameters
    ----------
    decomp_data : dict
        Parsed decomposition_results.json.
    output_dir : str
        Output directory.
    dpi : int
        Image resolution.

    Returns
    -------
    bool
        True if the figure was created.
    """
    save_path = os.path.join(output_dir, "fig8_decomposition_scatter.png")

    corr = decomp_data.get("tau_a_tau_e_correlation")
    mean_a = decomp_data.get("mean_tau_a")
    mean_e = decomp_data.get("mean_tau_e")
    std_a = decomp_data.get("std_tau_a")
    std_e = decomp_data.get("std_tau_e")

    if corr is None:
        return False

    fig, ax = plt.subplots(figsize=(5, 3.5))

    text_lines = [
        f"Pearson r = {corr:.4f}",
        "",
        f"$\\tau_a$: {mean_a:.4f} +/- {std_a:.4f}" if mean_a is not None else "",
        f"$\\tau_e$: {mean_e:.4f} +/- {std_e:.4f}" if mean_e is not None else "",
        "",
        "Full scatter generated by",
        "analyze_decomposition.py",
    ]
    text_lines = [l for l in text_lines if l is not None]

    ax.text(0.5, 0.5, "\n".join(text_lines),
            ha="center", va="center", transform=ax.transAxes,
            fontsize=LABEL_SIZE, family="monospace",
            bbox=dict(boxstyle="round,pad=0.5", facecolor="#e8f5e9",
                      edgecolor="gray"))
    ax.set_title(f"Temperature Decomposition (r={corr:.3f})")
    ax.set_xlabel(r"$\tau_a$ (Aleatoric)")
    ax.set_ylabel(r"$\tau_e$ (Epistemic)")

    fig.tight_layout()
    fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
    plt.close(fig)
    print(f"  Saved (summary): {save_path}")
    return True


# ============================================================================
# Figure 9: Blur Response Curves
# ============================================================================

def generate_fig9(decomp_data, output_dir, dpi):
    """Generate Fig 9: temperature response to blur levels.

    Parameters
    ----------
    decomp_data : dict
        Parsed decomposition_results.json with blur_response key.
    output_dir : str
        Output directory.
    dpi : int
        Image resolution.

    Returns
    -------
    bool
        True if the figure was created.
    """
    save_path = os.path.join(output_dir, "fig9_blur_response.png")

    blur = decomp_data.get("blur_response")
    if blur is None:
        return False

    levels = blur.get("levels", [])
    tau_a = blur.get("mean_tau_a", [])
    tau_e = blur.get("mean_tau_e", [])
    tau_total = blur.get("mean_tau_total", [])
    blur_corr = blur.get("tau_a_blur_corr")

    if not levels:
        return False

    fig, ax = plt.subplots(figsize=(5, 3.5))
    ax.plot(levels, tau_a, "o-", color="steelblue", label=r"$\tau_a$ (aleatoric)")
    ax.plot(levels, tau_e, "s-", color="coral", label=r"$\tau_e$ (epistemic)")
    ax.plot(levels, tau_total, "^-", color="gray", label=r"$\tau_{total}$")

    ax.set_xlabel("Blur Level")
    ax.set_ylabel("Mean Temperature")
    title = "Temperature Response to Image Blur"
    if blur_corr is not None:
        title += f"\n($\\tau_a$-blur r={blur_corr:.3f})"
    ax.set_title(title)
    ax.legend(loc="best")

    fig.tight_layout()
    fig.savefig(save_path, dpi=dpi, bbox_inches="tight")
    plt.close(fig)
    print(f"  Saved: {save_path}")
    return True


# ============================================================================
# CLI
# ============================================================================

def parse_args():
    parser = argparse.ArgumentParser(
        description="Generate all publication figures from Phase 3 analysis results",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    parser.add_argument(
        "--results_dir", type=str, default="./analysis_results",
        help="Root directory containing analysis result JSON files",
    )
    parser.add_argument(
        "--output_dir", type=str, default="./figures",
        help="Directory to save generated figures",
    )
    parser.add_argument(
        "--dpi", type=int, default=300,
        help="DPI for saved figures",
    )
    return parser.parse_args()


# ============================================================================
# Main
# ============================================================================

def main():
    args = parse_args()

    results_dir = os.path.abspath(args.results_dir)
    output_dir = os.path.abspath(args.output_dir)
    dpi = args.dpi

    print("=" * 70)
    print("Phase 4: Figure Generation")
    print("=" * 70)
    print(f"  Results dir: {results_dir}")
    print(f"  Output dir:  {output_dir}")
    print(f"  DPI:         {dpi}")
    print()

    os.makedirs(output_dir, exist_ok=True)
    _apply_ieee_style()

    # ------------------------------------------------------------------
    # Locate result files
    # ------------------------------------------------------------------
    paths = {
        "accuracy":       os.path.join(results_dir, "accuracy", "evaluation_results.json"),
        "ucat":           os.path.join(results_dir, "ucat", "ucat_analysis.json"),
        "ood":            os.path.join(results_dir, "ood", "ood_results.json"),
        "calibration":    os.path.join(results_dir, "calibration", "calibration_results.json"),
        "robustness":     os.path.join(results_dir, "robustness", "robustness_results.json"),
        "decomposition":  os.path.join(results_dir, "decomposition", "decomposition_results.json"),
    }

    data = {}
    print("Checking for analysis result files:")
    for key, path in paths.items():
        loaded = _load_json(path)
        data[key] = loaded
        status = "FOUND" if loaded is not None else "not found"
        print(f"  [{status:>9s}] {key}: {path}")
    print()

    # ------------------------------------------------------------------
    # Generate figures
    # ------------------------------------------------------------------
    generated = []
    skipped = []

    # Fig 2: tau vs Entropy Scatter
    print("--- Fig 2: tau vs Entropy Scatter ---")
    if data["ucat"] is not None:
        if generate_fig2(data["ucat"], output_dir, dpi):
            generated.append("fig2_tau_entropy_scatter.png")
        else:
            skipped.append("fig2_tau_entropy_scatter.png (insufficient data)")
    else:
        skipped.append("fig2_tau_entropy_scatter.png (ucat results not found)")
        print("  Skipped: ucat analysis results not found.")
    print()

    # Fig 3: Correct vs Wrong
    print("--- Fig 3: tau for Correct vs Wrong ---")
    if data["ucat"] is not None:
        if generate_fig3(data["ucat"], output_dir, dpi):
            generated.append("fig3_correct_vs_wrong.png")
        else:
            skipped.append("fig3_correct_vs_wrong.png (insufficient data)")
    else:
        skipped.append("fig3_correct_vs_wrong.png (ucat results not found)")
        print("  Skipped: ucat analysis results not found.")
    print()

    # Fig 4: OOD Detection
    print("--- Fig 4: OOD Detection ---")
    if data["ood"] is not None:
        if generate_fig4(data["ood"], output_dir, dpi):
            generated.append("fig4_ood_detection.png")
        else:
            skipped.append("fig4_ood_detection.png (insufficient data)")
    else:
        skipped.append("fig4_ood_detection.png (ood results not found)")
        print("  Skipped: OOD results not found.")
    print()

    # Fig 5: Calibration Comparison
    print("--- Fig 5: Calibration Comparison ---")
    if data["calibration"] is not None:
        if generate_fig5(data["calibration"], output_dir, dpi):
            generated.append("fig5_calibration_comparison.png")
        else:
            skipped.append("fig5_calibration_comparison.png (insufficient data)")
    else:
        skipped.append("fig5_calibration_comparison.png (calibration results not found)")
        print("  Skipped: calibration results not found.")
    print()

    # Fig 6: Robustness
    print("--- Fig 6: Robustness ---")
    if data["robustness"] is not None:
        if generate_fig6(data["robustness"], output_dir, dpi):
            generated.append("fig6_robustness.png")
        else:
            skipped.append("fig6_robustness.png (insufficient data)")
    else:
        skipped.append("fig6_robustness.png (robustness results not found)")
        print("  Skipped: robustness results not found.")
    print()

    # Fig 7: Ablation Accuracy Bar Chart
    print("--- Fig 7: Ablation Accuracy Bar Chart ---")
    if data["accuracy"] is not None:
        if generate_fig7(data["accuracy"], output_dir, dpi):
            generated.append("fig7_ablation_accuracy.png")
        else:
            skipped.append("fig7_ablation_accuracy.png (insufficient data)")
    else:
        skipped.append("fig7_ablation_accuracy.png (accuracy results not found)")
        print("  Skipped: accuracy results not found.")
    print()

    # Fig 8: Decomposition Scatter
    print("--- Fig 8: Decomposition Scatter ---")
    if data["decomposition"] is not None:
        if generate_fig8(data["decomposition"], output_dir, dpi):
            generated.append("fig8_decomposition_scatter.png")
        else:
            skipped.append("fig8_decomposition_scatter.png (insufficient data)")
    else:
        skipped.append("fig8_decomposition_scatter.png (decomposition results not found)")
        print("  Skipped: decomposition results not found.")
    print()

    # Fig 9: Blur Response
    print("--- Fig 9: Blur Response ---")
    if data["decomposition"] is not None:
        if generate_fig9(data["decomposition"], output_dir, dpi):
            generated.append("fig9_blur_response.png")
        else:
            skipped.append("fig9_blur_response.png (insufficient blur data)")
    else:
        skipped.append("fig9_blur_response.png (decomposition results not found)")
        print("  Skipped: decomposition results not found.")
    print()

    # ------------------------------------------------------------------
    # Summary
    # ------------------------------------------------------------------
    print("=" * 70)
    print("FIGURE GENERATION SUMMARY")
    print("=" * 70)

    if generated:
        print(f"\n  Generated ({len(generated)}):")
        for fig_name in generated:
            print(f"    + {os.path.join(output_dir, fig_name)}")
    else:
        print("\n  No figures were generated.")

    if skipped:
        print(f"\n  Skipped ({len(skipped)}):")
        for reason in skipped:
            print(f"    - {reason}")

    print()
    print(f"  Total: {len(generated)} generated, {len(skipped)} skipped")
    print("=" * 70)


if __name__ == "__main__":
    main()
